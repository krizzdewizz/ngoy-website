<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="">

<title>ngoy  - Docs</title>

<!-- Bootstrap core CSS -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">

<link rel="icon" type="image/png" href="favicon/favicon.png?v=2">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/vs.min.css">

<link rel="stylesheet" type="text/css" href="styles/main.css"></head>

<body>

	<!-- Navigation -->
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark static-top">
		<div class="container">
			<a href="/" class="navbar-brand">ngoy - Docs</a>
			<button type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div id="navbarResponsive" class="collapse navbar-collapse">
				<ul class="navbar-nav ml-auto">

					<li class="nav-item"><a class="nav-link" href="index">Home </a></li><li class="nav-item"><a class="nav-link" href="get-started">Getting started </a></li><li class="nav-item active"><a class="nav-link" href="doc">Docs </a></li><li class="nav-item"><a class="nav-link" href="motivation">Motivation </a></li>

					<li class="nav-item"><a href="https://github.com/krizzdewizz/ngoy" target="_blank" class="nav-link">GitHub</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Page Content -->
	<div class="container app-container">
		<div class="row">
			<div class="col">
				<doc><ngoy-title><h1 class="mt-5 ngoy-title">Documentation</h1></ngoy-title>

<markdown url="doc/doc.md" toc><p>All ngoy features and notable differences to Angular are documented here.</p>
<h1 id="running-ngoy">Running ngoy</h1>
<p>The simplest way to use ngoy's template engine is via the static <code>renderString()</code> or <code>renderTemplate()</code> methods:</p>
<pre><code class="language-java">Ngoy.renderString(&quot;hello {{ name }}&quot;, Context.of(&quot;name&quot;, &quot;world&quot;), System.out);

// hello world
</code></pre>
<p>The first parameter is the template. Text inside the double curly braces is treated as an expression (see <a href="#template-syntax--data-binding">Template Syntax &amp; Data Binding</a>).</p>
<p>The second parameter is the evaluation 'context' or <code>this</code> inside the template. Context can be an object and/or a bunch of variables.
In the example the variable <code>&quot;name&quot;</code> is assigned the value <code>&quot;world&quot;</code>.</p>
<p>The third parameter is the <code>OutputStream</code> to write to.</p>
<p><code>renderTemplate()</code> works exactly the same, except that the template is read from a resource via <code>Class#getResourceAsStream()</code>.</p>
<p>For a simple template this might be already enough.</p>
<p>If you want more like reusable components, custom functions (pipes), services... maybe a router... you'd start from ngoy's static <code>app()</code> method.</p>
<p>It expects the root component class as the first parameter:</p>
<pre><code class="language-java">@Component(selector = &quot;&quot;, template = &quot;hello {{ name  | uppercase }}&quot;)
public class AppComponent {
    public String name = &quot;world&quot;;
}

public static void main(String[] args) {
	// build once
    Ngoy&lt;AppComponent&gt; ngoy = Ngoy.app(AppComponent.class)
            .build();

	// render many times
	ngoy.render(System.out);
	// ngoy.render(System.out);
	// ngoy.render(System.out);
	// ngoy.render(System.out);
}

// hello WORLD
</code></pre>
<p><code>build()</code> compiles the template to Java byte code on the fly and returns an Ngoy instance which then renders the content to the given <code>OutputStream</code>.</p>
<p>It's supposed to build once, render many times.</p>
<p>Note: In Angular, you normally have an <code>index.html</code> which 'bootstraps' the root app. In ngoy, the root app <em>is</em> the page.</p>
<h1 id="components--templates">Components &amp; Templates</h1>
<p>A component is an ordinary Java class annotated with the <code>@Component</code> annotation:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, templateUrl = &quot;person.component.html&quot;)
public class PersonComponent {
}
</code></pre>
<p>Whenever ngoy encounters an HTML element that matches the CSS selector <code>selector</code>, the component 'takes over' the element. The component then controls the element itself (aka host element) and it's content (including attributes).</p>
<p>The component's template becomes the matching element's content.</p>
<p>Given this <code>person.component.html</code>:</p>
<pre><code class="language-html">&lt;h1&gt;Person details&lt;/h1&gt;
</code></pre>
<p>then this HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>will finally become:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;h1&gt;Person details&lt;/h1&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>A component can specify it's template either by a <code>templateUrl</code> or an inline <code>template</code>. The <code>templateUrl</code> is loaded with a call to <code>Class#getResourceAsStream()</code>.</p>
<p>Inline template:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, template = &quot;&lt;h1&gt;Person details&lt;/h1&gt;&quot;)
public class PersonComponent {
}
</code></pre>
<h2 id="template-syntax--data-binding">Template Syntax &amp; Data Binding</h2>
<p>A component has full control over the HTML by the use of data binding. There exists several possibilities:</p>
<h3 id="interpolation">Interpolation</h3>
<p>The text inside double curly braces is interpreted as an expression:</p>
<pre><code class="language-html">&lt;h1&gt;Person details: {{ person.name }}&lt;/h1&gt;
</code></pre>
<p>At runtime, the expression is evaluated and it's return value is rendered.</p>
<p>Note: ngoy uses the <a href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html">Spring EL</a> library for expression/evaluation. Please consult their docs for what is possible. It's syntax is almost conform to Angular.</p>
<p>The component designates the 'context' (aka <code>this</code>) of the evaluation. So <code>person</code> in <code>{{ person.name }}</code> designates the <code>person</code> field of the <code>PersonComponent</code> instance:</p>
<pre><code class="language-java">public class Person {
	public String name;
	public int age;
}

@Component(selector = &quot;person&quot;, template = &quot;&lt;h1&gt;Person details: {{ person.name }}&lt;/h1&gt;&quot;)
public class PersonComponent {
	public Person person;
}
</code></pre>
<p>Interpolation can occur also inside of attribute values:</p>
<pre><code class="language-html">&lt;h1 title=&quot;hello {{ person.name }}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h3 id="attribute-binding">Attribute Binding</h3>
<p>Beside interpolation, an attribute's value can also be evaluated at runtime with the use of attribute bindings; the preferred way.</p>
<p>Regular attribute:</p>
<pre><code class="language-html">&lt;h1 title=&quot;hello&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>The same with an attribute binding:</p>
<pre><code class="language-html">&lt;h1 [title]=&quot;person.name&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Just enclose the attribute's name with <code>[]</code> and it's value is interpreted as an expression.</p>
<p>Alternatively you can write also:</p>
<pre><code class="language-html">&lt;h1 [attr.title]=&quot;person.name&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>The <code>[attr.]</code> syntax is relevant when using the <a href="#hostbinding"><code>@HostBinding</code></a> annotation.</p>
<h4 id="class-attribute"><code>class</code> attribute</h4>
<p>The <code>class</code> attribute receives special treatment because it's value is effectively a class <em>list</em>.</p>
<p>A class can be added to the list by the use of the <code>[class.]</code> syntax:</p>
<pre><code class="language-html">&lt;h1 [class.vip]=&quot;isVip(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Which means: add <code>vip</code> to the class list if the result of the expression <code>isVip(person)</code> evaluates to <code>true</code>.</p>
<p>Several class bindings can occur:</p>
<pre><code class="language-html">&lt;h1 [class.vip]=&quot;isVip(person)&quot; [class.cool]=&quot;isCool(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If both evaluate to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 class=&quot;vip cool&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>An already existing class list will be merged into the final class list:</p>
<pre><code class="language-html">&lt;h1 class=&quot;person-title col-xs&quot; [class.vip]=&quot;isVip(person)&quot; [class.cool]=&quot;isCool(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If both evaluate to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 class=&quot;person-title col-xs vip cool&quot;&gt;&lt;/h1&gt;
</code></pre>
<h4 id="ngclass-attribute"><code>ngClass</code> attribute</h4>
<p>If several classes must be computed at once, it can be tedious to write them all with <code>[class.]</code> bindings. With the help of the <code>ngClass</code> attribute, you can add them all at once.</p>
<p>It expects a <code>java.util.Map&lt;String, Boolean&gt;</code> as the expression result:</p>
<pre><code class="language-html">&lt;h1 [ngClass]=&quot;personClasses&quot;&gt;&lt;/h1&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	...
	public Map&lt;String, Boolean&gt; personClasses = new HashMap&lt;&gt;();
	
	public void ngOnInit() {
		personClasses.put(&quot;vip&quot;, isVip(person));
		personClasses.put(&quot;cool&quot;, isCool(person));
	}
}
</code></pre>
<p>Or as an expression using Spring EL map literals:</p>
<pre><code class="language-html">&lt;h1 [ngClass]=&quot;{vip: isVip(person), cool: isCool(person)}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h4 id="style-attribute"><code>style</code> attribute</h4>
<p>The <code>style</code> attribute receives special treatment because it's value is effectively a <em>map</em> from the style's name to it's value.</p>
<p>A style entry can be added by the use of the <code>[style.]</code> syntax:</p>
<pre><code class="language-html">&lt;h1 [style.background-color]=&quot;isVip(person) ? 'red' : 'inherit'&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Which means: add <code>background-color</code> to the styles attribute with the value being the result of the expression.</p>
<p>If <code>isVip(person)</code> evaluates to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 style=&quot;background-color:red&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>You can append a unit to the style name, which is placed after the evaluated value:</p>
<pre><code class="language-html">&lt;h1 [style.width.px]=&quot;isVip(person) ? 240 : null&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If <code>isVip(person)</code> evaluates to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 style=&quot;width:240px&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Already existing styles will be merged into the final map.</p>
<p>As opposed to Angular, styles must not be camelCased.</p>
<p>Angular:</p>
<pre><code>[style.backgroundColor]=&quot;'red'&quot;
</code></pre>
<p>ngoy:</p>
<pre><code>[style.background-color]=&quot;'red'&quot;
</code></pre>
<h4 id="ngstyle-attribute"><code>ngStyle</code> attribute</h4>
<p>If several styles must be computed at once, it can be tedious to write them all with <code>[style.]</code> bindings. With the help of the <code>ngStyle</code> attribute, you can add them all at once.</p>
<p>It expects a <code>java.util.Map&lt;String, String&gt;</code> as the expression result:</p>
<pre><code class="language-html">&lt;h1 [ngStyle]=&quot;personStyles&quot;&gt;&lt;/h1&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	...
	public Map&lt;String, Boolean&gt; personStyles = new HashMap&lt;&gt;();
	
	public void ngOnInit() {
		personStyles.put(&quot;background-color&quot;, isVip(person) ? &quot;red&quot; : &quot;inherit&quot;);
		...
	}
}
</code></pre>
<p>Or as an expression using Spring EL map literals:</p>
<pre><code class="language-html">&lt;h1 [ngStyle]=&quot;{'background-color': isVip(person) ? 'red' : 'inherit'}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h3 id="hostbinding">@HostBinding</h3>
<p>The attributes of a component's host element can be dynamically set using the <code>@HostBinding</code> annotation. It is set on a component's field (or getter).</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;&lt;/person&gt; &lt;!-- host element --&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	@HostBinding(&quot;class.vip&quot;)
	public boolean isVip;
	
	public void ngOnInit() {
		isVip = calculateVipStatus(person);
	}
}
</code></pre>
<p>The <code>@HostBinding</code>'s value is one of the bindings mentioned above (without the brackets): <code>attr.</code>, <code>class.</code>, <code>style.</code>. The type of the field  must correspond to the attribute kind:</p>
<ul>
<li><code>&quot;attr.title&quot;</code> -&gt; <code>String</code>. Value for the <code>title</code> attribute.</li>
<li><code>&quot;class.vip&quot;</code> -&gt; <code>boolean</code>. <code>true</code> if class <code>vip</code> should be added to the class list.</li>
<li><code>&quot;style.background-color&quot;</code> -&gt; <code>String</code>. Value for the style.</li>
<li><code>&quot;ngText&quot;</code> -&gt; <code>String</code>. Value for the element's text content. This is an extension to Angular.</li>
</ul>
<h2 id="lifecycle-hooks">Lifecycle hooks</h2>
<p>Ngoy supports two lifecycle hooks. <code>OnInit</code> and <code>OnDestroy</code>:</p>
<pre><code class="language-java">...
public class PersonComponent implements OnInit, OnDestroy {
	
	public void ngOnInit() {
	}

	public void ngOnDestroy() {
	}
}
</code></pre>
<p><code>ngOnInit()</code> is called in the rendering phase each time the component, resp. it's host element starts.</p>
<p>Typically, a component computes field values in <code>ngOnInit()</code>, may using an injected service.</p>
<p>Note: A new component instance is created each time it is entered.
Initialization can happen in the constructor as long as no injected dependecies are used.
At construction time, fields are not injected yet, but in <code>ngOnInit()</code>, they are.</p>
<p><code>ngOnDestroy()</code> is called in the rendering phase each time the component, resp. it's host element ends.</p>
<h2 id="component-interaction">Component Interaction</h2>
<p>You can pass data from a parent component to a child component with an input binding:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	@Input
	public Person thePerson;
}

@Component(selector = &quot;&quot;, template = &quot;&lt;person [thePerson]=\&quot;peter\&quot;&gt;&lt;/person&gt;&quot;)
@NgModule(declarations = { PersonComponent.class })
public class AppComponent {
	public Person peter = new Person(&quot;Peter&quot;);
}
</code></pre>
<p><code>PersonComponent</code> declares <code>thePerson</code> field as an <code>@Input</code> binding.</p>
<p>The input parameter is passed to the <code>PersonComponent</code> instance with the use of an attribute binding <code>[thePerson]</code>:</p>
<pre><code class="language-html">&lt;person [thePerson]=&quot;peter&quot;&gt;&lt;/person&gt;
</code></pre>
<p><code>[]</code> designates an expression. its value, <code>peter</code>, is assigned to the component's input <code>thePerson</code>.</p>
<p>The <code>@Input</code> can optionally be renamed:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	@Input(&quot;personas&quot;)
	public Person thePerson;
}
</code></pre>
<pre><code class="language-html">&lt;person [personas]=&quot;peter&quot;&gt;&lt;/person&gt;
</code></pre>
<p>The <code>@Input</code> annotation can also be specified on a 'setter':</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	private Person _person;
	
	@Input(&quot;personas&quot;)
	public void setThePerson(Person person) {
		_person = person;
	}
}
</code></pre>
<p>An <code>@Input</code> field must be public, non-static and non-final.</p>
<h2 id="component-styles">Component styles</h2>
<p>A component can specify inline <code>style</code>s or resources identified by <code>styleUrls</code>:</p>
<pre><code class="language-java">@Component(
	selector = &quot;person&quot;, 
	styleUrls = { &quot;person.component.css&quot; },
	styles = { &quot;h1 { font-weight: normal; }&quot; })
public class PersonComponent {
}
</code></pre>
<p>Upon compilation of the template, all styles from all declared components are copied into a single <code>&lt;style&gt;</code> element in the app's HTML.</p>
<h3 id="auto-prefixer">Auto Prefixer</h3>
<p>By default, styles are copied 'as-is'; they are global and not scoped to the component (no shadow DOM).</p>
<p>You can, however, opt-in to auto-prefixing:</p>
<pre><code class="language-java">Ngoy.app(AppComponent.class)
	.prefixCss(true) // enable auto-prefixer 
	.build();
</code></pre>
<p>All style rules are prefixed with the component's selector.</p>
<p>In the above example, with prefix enabled, the style</p>
<pre><code class="language-css">h1 { font-weight: normal; }
</code></pre>
<p>would be translated to:</p>
<pre><code class="language-css">person h1 { font-weight: normal; }
</code></pre>
<h2 id="attribute-directives">Attribute Directives</h2>
<p>Directives are annotated with the <code>@Directive</code> annotation:</p>
<pre><code class="language-java">@Directive(selector = &quot;[appHighlight]&quot;)
public class HighlightDirective {
	@HostBinding(&quot;style.background-color&quot;)
	public String getBgColor() {
	 	String color = ...;
		return color;
	}
}
</code></pre>
<p>A directive is aka a 'component without a template'. All rules of a component apply also to a directive, except that the host element's content is not replaced by any template. So a directive serves merely to change the attributes of the host element with the use of <code>@HostBinding</code>s, or as a <a href="#compile-time-hook">compile-time hook</a>.</p>
<h2 id="control-structures">Control Structures</h2>
<p>Control structures allows you to alter a host element's subtree by adding, removing or manipulating elements.</p>
<h3 id="ngif">*ngIf</h3>
<p><code>*ngIf</code> allows you to conditionally include an element in the subtree.</p>
<pre><code class="language-html">&lt;h1&gt;Person details &lt;span *ngIf=&quot;isVip(person)&quot;&gt;VIP!&lt;/span&gt;&lt;/h1&gt;
</code></pre>
<p>The value of the <code>*ngIf</code> attribute designates an expression. The element is rendered only when the expression evaluates to <code>true</code>.</p>
<p>You can optionally add an <code>else</code> clause:</p>
<pre><code class="language-html">&lt;h1&gt;Person details &lt;span *ngIf=&quot;isVip(person); else regularPerson&quot;&gt;VIP!&lt;/span&gt;&lt;/h1&gt;

&lt;ng-template #regularPerson&gt;
	&lt;span&gt;No hor d'oeuvres for this guy&lt;span&gt;
&lt;/ng-template&gt;
</code></pre>
<h3 id="ngswitch">[ngSwitch]</h3>
<p><code>[ngSwitch]</code> allows you to switch on a once evaluated expression and 'jump' to one or more <code>*ngSwitchCase</code> labels:</p>
<pre><code class="language-html">&lt;h1 [ngSwitch]=&quot;emotion&quot;&gt;
    &lt;div *ngSwitchCase=&quot;'happy'&quot;&gt;üôÇ&lt;/div&gt;
    &lt;div *ngSwitchCase=&quot;'sad'&quot;&gt;üôÅ&lt;/div&gt;
    &lt;div *ngSwitchDefault&gt;üòê&lt;/div&gt;
&lt;/h1&gt;
</code></pre>
<p>The first <code>*ngSwitchCase</code> matching the expression <code>emotion</code> will be rendered. If none of the cases match, <code>*ngSwitchDefault</code> is rendered.</p>
<p>A <code>[ngSwitch]</code> must have at least one <code>*ngSwitchCase</code>.</p>
<p><code>[ngSwitch]</code> can switch on any type of value.</p>
<h3 id="ngfor">*ngFor</h3>
<p><code>*ngFor</code> allows you to repeat an element for every item in an <code>Iterator</code> or array.</p>
<pre><code class="language-html">&lt;div *ngFor=&quot;let person of persons&quot;&gt;{{ person.name }}&lt;/div&gt;
</code></pre>
<p><code>persons</code> may be an instance of <code>Iterable</code> or an array. <code>person</code> designates the current item of the iteration,
which is available as a local variable inside the <code>&lt;div&gt;</code>.</p>
<p>This is the same as Java's enhanced for loop:</p>
<pre><code class="language-java">for (Person person : persons) {
}
</code></pre>
<p>Optionally, you can declare local aliases for the built-in iteration variables, delimited with <code>;</code></p>
<pre><code class="language-html">&lt;div *ngFor=&quot;let person of persons; index as i; first as f&quot;&gt;
	{{ person.name }}, person index: {{ i }}
&lt;/div&gt;
</code></pre>
<p>The built-in variables are:</p>
<ul>
<li><code>index</code>: The current iteration index starting at <code>0</code></li>
<li><code>first</code>: <code>true</code> if this is the first iteration</li>
<li><code>last</code>: <code>true</code> if this is the last iteration</li>
<li><code>even</code>: <code>true</code> if <code>index</code> is even</li>
<li><code>odd</code>: <code>true</code> if <code>index</code> is odd</li>
</ul>
<h2 id="ng-content">&lt;ng-content&gt;</h2>
<p>A component may include the host element's content into it's own template. This is known as 'content projection'.</p>
<p>The &lt;ng-content&gt; element inside the component's template is replaced by the contents of the host element:</p>
<p>Given this <code>PersonComponent</code> template:</p>
<pre><code class="language-html">&lt;h1&gt;Person details: {{ person.name }}
	&lt;ng-content&gt;&lt;/ng-content&gt; &lt;!-- where the content is projected to --&gt;
&lt;/h1&gt;
</code></pre>
<p>then this HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;!-- everthing inside &lt;person&gt; is projected --&gt;
		&lt;div&gt;More person details&lt;/div&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>will finally become:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;h1&gt;Person details: Peter
			&lt;div&gt;More person details&lt;/div&gt; &lt;!-- projection done --&gt;
		&lt;/h1&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>A &lt;ng-content&gt; element may have a CSS <code>select</code> attribute. When this attribute is given,
the first element inside the host element matching the selector will be projected:</p>
<p>Given this template:</p>
<pre><code class="language-html">&lt;h1&gt;Person details: {{ person.name }}
	&lt;!-- project element with moreDetails attribute --&gt;
	&lt;ng-content select=&quot;[moreDetails]&quot;&gt;&lt;/ng-content&gt;
	&lt;br&gt;
	&lt;!-- project element with personLinks attribute --&gt;
	&lt;ng-content select=&quot;[personLinks]&quot;&gt;&lt;/ng-content&gt;
&lt;/h1&gt;
</code></pre>
<p>then this HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;div moreDetails&gt;More person details&lt;/div&gt;
		&lt;div personLinks&gt;Links&lt;/div&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>will finally become:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;h1&gt;Person details: Peter
			&lt;div moreDetails&gt;More person details&lt;/div&gt;
			&lt;br&gt;
			&lt;div personLinks&gt;Links&lt;/div&gt;
		&lt;/h1&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<h2 id="ng-container">&lt;ng-container&gt;</h2>
<p>&lt;ng-container&gt; behaves like any other element except that it is never rendered but only it's content.</p>
<p>Using &lt;ng-container&gt;, you can often spare an element that would otherwise be used only for grouping:</p>
<p>Instead of:</p>
<pre><code class="language-html">&lt;div *ngFor=&quot;let person of persons; index as i&quot;&gt;    &lt;!-- we don't need that div --&gt;  
	&lt;span&gt;name: {{ person.name }}&lt;/span&gt;
	&lt;span&gt;index: {{ i }}&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>You can write:</p>
<pre><code class="language-html">&lt;ng-container *ngFor=&quot;let person of persons; index as i&quot;&gt;    &lt;!-- will disappear --&gt;  
	&lt;span&gt;name: {{ person.name }}&lt;/span&gt;
	&lt;span&gt;index: {{ i }}&lt;/span&gt;
&lt;/ng-container&gt;
</code></pre>
<p>that will produce:</p>
<pre><code class="language-html">&lt;span&gt;name: Peter&lt;/span&gt;
&lt;span&gt;index: 0&lt;/span&gt;
&lt;span&gt;name: Paul&lt;/span&gt;
&lt;span&gt;index: 1&lt;/span&gt;
&lt;span&gt;name: Mary&lt;/span&gt;
&lt;span&gt;index: 2&lt;/span&gt;
</code></pre>
<h2 id="compile-time-hook">Compile-time Hook</h2>
<p>When the template is compiled, a component/directive has the chance to alter the template's subtree before the compiler sees it. At this point, you can i.e. insert static content, re-write or expand a template based on some attributes etc.</p>
<p>A component/directive may implement the <code>OnCompile</code> interface:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent implements OnCompile {
	public void ngOnCompile(Jerry el, String componentClass) {
		// changes to the DOM element 'el', it's attributes 
		// and content will be picked up by the compiler
	}
}
</code></pre>
<p><code>ngOnCompile()</code> is called only <em>once</em> in the compile phase and not in the rendering phase.</p>
<p>See the <a href="https://github.com/krizzdewizz/ngoy-website/blob/master/src/main/java/ngoyweb/app/components/markdown/MarkdownComponent.java">MarkdownComponent</a> for an example. It appends the HTML converted from CommonMark. You can write markdown inside the component or reference a <code>.md</code> resource.</p>
<h2 id="pipes">Pipes</h2>
<p>A pipe takes data as input and transforms it to a desired output. You can pipe the result of an expression to the desired pipe:</p>
<pre><code class="language-html">&lt;h1&gt;hello:  {{ person.name | uppercase }}&lt;/h1&gt;
</code></pre>
<p>A pipe may have parameters delimited by colon <code>:</code></p>
<pre><code class="language-html">{{ T(LocalDateTime).of(2018, 10, 28, 12, 44)  |  date:'MMMM YYYY' }} 
</code></pre>
<p>Prints</p>
<pre><code>October 2018
</code></pre>
<p>These are the built-in pipes:</p>
<ul>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/UpperCasePipe.java">uppercase</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/LowerCasePipe.java">lowercase</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/CapitalizePipe.java">capitalize</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/DatePipe.java">date</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/translate/TranslatePipe.java">translate</a> (see <a href="#translate">Translate Module</a>)</li>
</ul>
<p>Of course you can write your own:</p>
<p>Annotate a Java class with <code>@Pipe</code> and implement the <code>PipeTransform</code> interface.</p>
<p>The original <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/UpperCasePipe.java">uppercase</a> source:</p>
<pre><code class="language-java">@Pipe(&quot;uppercase&quot;)
public class UpperCasePipe implements PipeTransform {

	@Inject
	public LocaleProvider localeProvider;

	@Override
	public Object transform(@Nullable Object obj, Object... params) {
		if (obj == null) {
			return null;
		}

		return obj.toString().toUpperCase(localeProvider.getLocale());
	}
}
</code></pre>
<p>Note: The pipe syntax <code>|</code> is not part of the Spring EL grammar. ngoy parses it 'manually' with regex. It should be fine in most cases, but in complex expressions (which should be avoided anyway) it could lead to a parse error. In such a situation, you can always resort to the function call syntax, prefixing the pipe with <code>$</code>:</p>
<pre><code class="language-java">'hello' | uppercase | greet
</code></pre>
<p>is the same as:</p>
<pre><code class="language-java">$greet($uppercase('hello'))
</code></pre>
<h2 id="plain-text-templates">Plain Text Templates</h2>
<p>ngoy renders plain text formats (no markup) and you can nevertheless use components the same way as with regular templates.</p>
<p>Just set the root component's <code>contentType</code> to <code>&quot;text/plain&quot;</code>.</p>
<p>A complete example:</p>
<pre><code class="language-java">@Component(selector = &quot;header&quot;, template = &quot;Welcome, {{ name }}\n&quot;)
public class HeaderCmp {
	@Input
	public String name;
}

@Component(selector = &quot;footer&quot;, template = &quot;sincerely&quot;)
public class FooterCmp {
}

// set contentType to text/plain
@Component(selector = &quot;&quot;, contentType = &quot;text/plain&quot;, templateUrl = &quot;mail.txt&quot;)
@NgModule(declarations = { HeaderCmp.class, FooterCmp.class })
public class AppComponent {
	public Person person = new Person(&quot;peter&quot;, 22);
	public String[] hobbies = new String[] { &quot;music&quot;, &quot;surfing&quot;, &quot;dancing&quot; };
}
</code></pre>
<p><code>mail.txt</code>:</p>
<pre><code>&lt;header [name]=&quot;person.name&quot;&gt;&lt;/header&gt;
age: {{ person.age }}
hobbies:
&lt;span *ngFor=&quot;let h of hobbies&quot;&gt;	{{ h }}
&lt;/span&gt;
&lt;footer&gt;&lt;/footer&gt;
</code></pre>
<p>Produces:</p>
<pre><code>Welcome, peter

age: 22
hobbies:
	music
	surfing
	dancing

sincerely
</code></pre>
<p><code>text/plain</code> characteristics:</p>
<ul>
<li>no output escaping takes place</li>
<li>all components/elements are inlined, just like <a href="#ng-container">&lt;ng-container&gt;</a></li>
</ul>
<h2 id="xml-templates">XML Templates</h2>
<p>ngoy makes no distinction between XML and HTML. It's totally the same.</p>
<h1 id="modules">Modules</h1>
<p>All components, directives, pipes (declarations) and providers/services must be registered within ngoy.</p>
<p>Given the person example from above:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
}

@Component(selector = &quot;&quot;, template = &quot;&lt;person&gt;&lt;/person&gt;&quot;)
@NgModule(declarations = { PersonComponent.class }) // make PersonComponent known to ngoy
public class AppComponent {
	public Person peter = new Person(&quot;Peter&quot;);
}
</code></pre>
<p>Without the <code>NgModule</code> annotation, the <code>PersonComponent</code> would be unknown to ngoy and the <code>&lt;person&gt;</code> element would not match any selector and it would just stay there as it is.</p>
<p>A class annotated with <code>NgModule</code> serves as a container for declarations and providers. A logical unit to group a feature together.
May a component needs a provider or other components to work correctly. So you would group them into a module, so that clients of your component can import just the module instead of all parts separately. And you could add more stuff to the module afterwards without breaking the clients.</p>
<p>A <code>NgModule</code> has three attributes:</p>
<ul>
<li><code>declarations</code>: make components, directives and pipes known to ngoy</li>
<li><code>providers</code>: make providers/services known to ngoy</li>
<li><code>imports</code>: imports other <code>NgModule</code>s, making them known to ngoy recursively</li>
</ul>
<p>Note: Unlike other module systems, there exists no boundaries between modules. At the end, everything is stuffed into a single map. Everything can be reached from anywhere.</p>
<p>A runtime exception is thrown whenever more than one component matches an element.</p>
<p>A provider can also be specified on a <code>@Component</code> to spare a <code>NgModule</code>:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, providers = { PersonService.class }) 
public class PersonComponent {
}
</code></pre>
<p>Component providers are <strong>never</strong> local to a component but <strong>always</strong> global.</p>
<p>A <code>@Component</code> can also be a <code>@NgModule</code>.</p>
<h2 id="dynamic-modules">Dynamic Modules</h2>
<p>A dynamic module's declarations/providers are computed at runtime instead of 'declaration time' with annotations.</p>
<p>See <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/core/ModuleWithProviders.java">ModuleWithProviders.java</a> and
<a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/router/RouterModule.java">RouterModule.java</a> for an example usage.</p>
<h2 id="package-modules">Package Modules</h2>
<p>It can be tedious to add every single thing to a module. And in an isolated app, there's no risk that there would be collisions.</p>
<p>In addition to organize declarations with modules, ngoy can scan the class path for them:</p>
<pre><code class="language-java">ngoy.app(AppComponent.class)

	// load all declarations/providers inside org.myapp package
	.modules(&quot;org.myapp&quot;)                     

	// load all declarations/providers inside the app's package
	.modules(AppComponent.class.getPackage())

	.build();
</code></pre>
<p>Note: Services must be annotated with <code>@Injectable</code> so that the class scanner picks it up as a provider:</p>
<pre><code class="language-java">@Injectable
public class PersonService {
	public Person[] getPersons() {
		return ...;
	}
}
</code></pre>
<h1 id="dependency-injection">Dependency Injection</h1>
<p>Any class can be registered as a service/provider within ngoy and be injected into declarations and other services.</p>
<p>ngoy supports field injection and constructor injection.</p>
<pre><code class="language-java">public class PersonService {
	public Person[] getPersons() {
		return ...;
	}
}

public class WeatherService {
}

@Component(selector = &quot;person&quot;, providers = { PersonService.class, WeatherService.class }) 
public class PersonComponent implements OnInit {

	// constructor injection
	public PersonComponent(WeatherService weatherService) {
		// do things with weatherService
	}

	// field injection
	@Inject
	public PersonService personService;
	
	public void ngOnInit() {
		// do things with personService
	}
}
</code></pre>
<p>Fields must be public, non-static, non-final and annotated with <code>@Inject</code>. Constructor parameters must not be annotated.</p>
<p>A runtime exception is thrown if there's no provider for a service. A dependency may be declared <code>@Optional</code> in which case no exception is thrown.</p>
<p>Note: a service must be annotated with <code>@Injectable</code> when it should be picked up by <a href="#package-modules">Package Modules</a>.</p>
<p>There are 3 kinds of providers:</p>
<ul>
<li><code>class A</code> -&gt; <code>class A</code>: Wherever <code>class A</code> is requested, inject an instance of <code>class A</code> (example above)</li>
<li><code>class A</code> -&gt; <code>useClass B</code>: Wherever <code>class A</code> is requested (could be an interface), inject an instance of <code>class B</code>, which must be assignable to <code>class A</code>. Used to override default behaviour.</li>
<li><code>class A</code> -&gt; <code>useValue V</code>: Wherever <code>class A</code> is requested (could be an interface), inject the instance <code>V</code>, which must be an instance of <code>class A</code>. Only available at runtime, not with annotations.</li>
</ul>
<h2 id="providers-at-runtime">Providers at Runtime</h2>
<p>Providers can be specified at runtime, especially the <code>useValue</code> variant, which is used to inject external dependencies into ngoy.</p>
<pre><code class="language-java">
// 'service' may be an Spring repository/service or an instance created by you

ngoy.app(AppComponent.class)
	.providers(Provider.useValue(MyService.class, service)
	.build();
</code></pre>
<p>See also <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/core/Provider.java">Provider.java</a></p>
<h2 id="external-di-systems">External DI Systems</h2>
<p>By implementing the <code>Injector</code> interface, one can provide dependencies from other DI systems such as Spring Boot to ngoy.</p>
<p>See <a href="https://github.com/krizzdewizz/ngoy-tour-of-heroes/blob/master/src/main/java/toh/app/BeanInjector.java">BeanInjector.java</a> for an example.</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/**&quot;)
public class Main implements InitializingBean {

	...

	@Autowired
	private BeanInjector beanInjector;

	private void createApp() {
		ngoy = Ngoy.app(AppComponent.class)
			...
			.injectors(beanInjector) // make Spring beans known to ngoy
			.build();
	}
}
</code></pre>
<h1 id="built-in-modules">Built-in Modules</h1>
<p>The following modules are contained in the ngoy binaries.
See the module's documentation below on how they must be imported into your app.</p>
<h2 id="router">Router</h2>
<p>Basic routing functionality can be found in the <code>RouterModule</code>. See the <a href="https://github.com/krizzdewizz/ngoy-examples/tree/master/src/main/java/ngoyexamples/routing">router</a> example in the <a href="https://github.com/krizzdewizz/ngoy-examples">ngoy-examples</a> collection.</p>
<h2 id="translate">Translate</h2>
<p>Using the <code>TranslateModule</code>, you can easily translate text in your templates using the standard Java way with message bundles.</p>
<p>The easiest way to include translation support is to build the ngoy instance with a call to <code>translateBundle()</code>:</p>
<pre><code class="language-java">Ngoy&lt;AppComponent&gt; ngoy = Ngoy.app(AppComponent.class)
	.translateBundle(&quot;messages&quot;) // PropertyResourceBundle 'baseName'
	.build();
</code></pre>
<p><code>translateBundle()</code> adds the <code>TranslateModule</code> to ngoy and configures the <code>TranslateService</code> to load the <code>PropertyResourceBundle</code> named <code>&quot;messages&quot;</code>.</p>
<p>Given these message bundles:</p>
<p><code>messages_en.properties</code>:</p>
<pre><code>MSG_GREETING=hello world
</code></pre>
<p>and <code>messages_de.properties</code>:</p>
<pre><code>MSG_GREETING=hallo welt
</code></pre>
<p>then in your template, you can obtain the translation/message for a given key using either the <code>translate</code> pipe:</p>
<pre><code class="language-html">&lt;h1&gt;{{ 'MSG_GREETING' | translate  }}&lt;/h1&gt;
</code></pre>
<p>or the <code>translate</code> directive:</p>
<pre><code class="language-html">&lt;h1 translate=&quot;MSG_GREETING&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>The current locale for the translation is held by the <code>LocaleProvider</code>. Default is <code>Locale#getDefault()</code>.</p>
<p>Given a german locale, both will render:</p>
<pre><code class="language-html">&lt;h1&gt;hallo welt&lt;/h1&gt;
</code></pre>
<p>You can override the locale by providing another <code>LocaleProvider</code>:</p>
<pre><code class="language-java">Ngoy&lt;AppComponent&gt; ngoy = Ngoy.app(AppComponent.class)
	.translateBundle(&quot;messages&quot;)
	.providers(
		Provider.useValue(LocaleProvider.class, new LocaleProvider.Default(Locale.ENGLISH)))
	.build();
</code></pre>
<p>or use the session's locale (Spring Boot):</p>
<pre><code class="language-java">Ngoy&lt;AppComponent&gt; ngoy = Ngoy.app(AppComponent.class)
	.translateBundle(&quot;messages&quot;)
	.providers(
		Provider.useValue(LocaleProvider.class, LocaleContextHolder::getLocale))
	.build();
</code></pre>
<p>Parameters are supported by the <code>translate</code> pipe:</p>
<pre><code>MSG_GREET_WITH_PARAM=hello {0}
</code></pre>
<pre><code class="language-html">&lt;h1&gt;{{ 'MSG_GREET_WITH_PARAM' | translate: 'world'  }}&lt;/h1&gt;
</code></pre>
<p>You can inject <code>TranslateService</code> anywhere for translations in code:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent implements OnInit {
	
	@Inject
	public TranslateService translateService;
	
	public void ngOnInit() {
		String greeting = translateService.translate(&quot;MSG_GREET_WITH_PARAM&quot;, &quot;world&quot;);
		...
	}
}
</code></pre>
<h2 id="forms">Forms</h2>
<p>to be done.</p>
<h1 id="unit-testing">Unit Testing</h1>
<p>Unit testing your components, directives, pipes etc. is a piece of cake. ngoy can render any component, not just the 'app'.
You can provide mock services or quickly have a container that uses your component.</p>
<p>See <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/test/java/ngoy/ANgoyTest.java"><code>ANgoyTest.java</code></a> to get started or any of the other <a href="https://github.com/krizzdewizz/ngoy/tree/master/ngoy/src/test/java/ngoy">~190 tests</a>.</p>
<p>Example:</p>
<pre><code class="language-java">public class ContainerTest extends ANgoyTest {
	@Component(
		selector = &quot;test&quot;, 
		template = &quot;a&lt;ng-container *ngFor=\&quot;let s of strings\&quot;&gt;{{s}}&lt;/ng-container&gt;b&quot;)
	public static class CmpRepeated {
		public String[] strings = new String[] { &quot;w&quot;, &quot;x&quot;, &quot;q&quot; };
	}
	
	@Test
	public void testRepeated() {
		assertThat(render(CmpRepeated.class)).isEqualTo(&quot;awxqb&quot;);
	}
}
</code></pre>
<h1 id="cli">CLI</h1>
<p>ngoy has a built in CLI with which you can</p>
<ul>
<li>render templates and expressions from the command line</li>
<li>quickly generate source code artifacts for new projects, components, pipes etc.</li>
</ul>
<p>The CLI main class is <code>ngoy.Ngoy</code>. When you started with <a href="https://github.com/krizzdewizz/ngoy-starter-web">ngoy-starter-web</a>,
the ngoy binaries and a shell script <code>ngoy</code> are ready to use:</p>
<pre><code>$ ./ngoy

usage: ngoy [g|gen|generate] [options] template

If generate is given, the rest of the arguments are passed over to
ngoy-gen.

Options:
 -e,--expression              treat template as an expression
 -f,--file                    read template from file instead of command
                              line
 -h,--help                    display this help
 -in,--input                  run template for each line read from stdin
                              (use $ variable to access line within
                              template)
 -v,--variable &lt;name=value&gt;   add a variable to the execution context
    --version                 print version information
</code></pre>
<p>Evaluate an expression:</p>
<pre><code>$ ./ngoy -e &quot;T(LocalDateTime).now()&quot;

2018-12-03T00:07:33.187
</code></pre>
<h2 id="generate-source-artifactes">Generate Source Artifactes</h2>
<p>Using the <code>ngoy gen</code> command you can generate source code artifacts:</p>
<pre><code>$ ./ngoy gen

usage: ngoy-gen [options] component|directive|pipe|module|service name

name should be lower-case-separated-with-dashes.

Examples:
  ngoy-gen component person-list
  ngoy-gen -p com.example pipe quantity-format

Shortcuts works as well:
  ngoy-gen p my-pipe

Options:
 -h,--help            display this help
 -p,--package &lt;arg&gt;   package prefix for the generated artifact. Default
                      is 'ngoygen'.
 -t,--target &lt;arg&gt;    target folder for the generated artifacts. A default
                      is searched in the following order:
                      [./src/main/java, ./src, .]
    --version         print version information

</code></pre>
<p>Generate a component:</p>
<pre><code>$ ./ngoy g c person

generating artifact '.\src\main\java\ngoygen\person\PersonComponent.java'...
generating artifact '.\src\main\java\ngoygen\person\person.component.html'...
generating artifact '.\src\main\java\ngoygen\person\person.component.css'...
</code></pre>
<h1 id="spring-el">Spring EL</h1>
<p>ngoy uses the <a href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html">Spring EL</a> library for expression/evaluation.</p>
<p>Here are some notable differences to the Angular syntax:</p>
<p>Truthy/falsy values do not exist. Expressions like this won't work:</p>
<pre><code class="language-html">&lt;!-- runtime error: person is not a boolean --&gt;
&lt;h1 *ngIf=&quot;person&quot;&gt;{{ person.name }}&lt;/h1&gt; 

&lt;!-- runtime error: length is not a boolean --&gt;
&lt;h1 *ngIf=&quot;persons.length&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>You have to write:</p>
<pre><code class="language-html">&lt;h1 *ngIf=&quot;person != null&quot;&gt;{{ person.name }}&lt;/h1&gt;

&lt;h1 *ngIf=&quot;persons.length &gt; 0&quot;&gt;&lt;/h1&gt;
</code></pre>
<p><code>===</code> does not exist. Use <code>==</code> instead.</p>
<p>List and Map literals are nice:</p>
<pre><code>// list
{1, 2, 3}

// map
{a: 1, b: 2, c: 3}
</code></pre>
<p>I.e.</p>
<pre><code class="language-html">&lt;ng-container *ngFor=&quot;let x of {1, 2, 3}&quot;&gt;{{ x }}&lt;/ng-container&gt;
</code></pre>
<p>will print:</p>
<pre><code>123
</code></pre>
<markdown-toc class="d-none d-md-block">
<a href="#running-ngoy" style="margin-left:20px">Running ngoy</a><a href="#components--templates" style="margin-left:20px">Components &amp; Templates</a><a href="#template-syntax--data-binding" style="margin-left:40px">Template Syntax &amp; Data Binding</a><a href="#interpolation" style="margin-left:60px">Interpolation</a><a href="#attribute-binding" style="margin-left:60px">Attribute Binding</a><a href="#hostbinding" style="margin-left:60px">@HostBinding</a><a href="#lifecycle-hooks" style="margin-left:40px">Lifecycle hooks</a><a href="#component-interaction" style="margin-left:40px">Component Interaction</a><a href="#component-styles" style="margin-left:40px">Component styles</a><a href="#auto-prefixer" style="margin-left:60px">Auto Prefixer</a><a href="#attribute-directives" style="margin-left:40px">Attribute Directives</a><a href="#control-structures" style="margin-left:40px">Control Structures</a><a href="#ng-content" style="margin-left:40px">&lt;ng-content&gt;</a><a href="#ng-container" style="margin-left:40px">&lt;ng-container&gt;</a><a href="#compile-time-hook" style="margin-left:40px">Compile-time Hook</a><a href="#pipes" style="margin-left:40px">Pipes</a><a href="#plain-text-templates" style="margin-left:40px">Plain Text Templates</a><a href="#xml-templates" style="margin-left:40px">XML Templates</a><a href="#modules" style="margin-left:20px">Modules</a><a href="#dynamic-modules" style="margin-left:40px">Dynamic Modules</a><a href="#package-modules" style="margin-left:40px">Package Modules</a><a href="#dependency-injection" style="margin-left:20px">Dependency Injection</a><a href="#providers-at-runtime" style="margin-left:40px">Providers at Runtime</a><a href="#external-di-systems" style="margin-left:40px">External DI Systems</a><a href="#built-in-modules" style="margin-left:20px">Built-in Modules</a><a href="#router" style="margin-left:40px">Router</a><a href="#translate" style="margin-left:40px">Translate</a><a href="#forms" style="margin-left:40px">Forms</a><a href="#unit-testing" style="margin-left:20px">Unit Testing</a><a href="#cli" style="margin-left:20px">CLI</a><a href="#generate-source-artifactes" style="margin-left:40px">Generate Source Artifactes</a><a href="#spring-el" style="margin-left:20px">Spring EL</a></markdown-toc></markdown></doc>
			</div>
		</div>
	</div>

	<!-- Bootstrap core JavaScript -->
	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<script>
	$(document).ready(function() {
	  $('pre code[class*=language]').each(function(i, block) {
	    hljs.highlightBlock(block);
	  });
	});
</script>
</body>

</html>
