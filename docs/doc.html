<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="">
<meta name="author" content="">

<title>ngoy  - Docs</title>

<!-- Bootstrap core CSS -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet">

<link rel="icon" type="image/png" href="favicon/favicon.png?v=2">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css">

<link rel="stylesheet" type="text/css" href="styles/main.css"></head>

<body>

	<!-- Navigation -->
	<nav class="navbar navbar-expand-lg navbar-dark bg-dark static-top">
		<div class="container">
			<a href="/" class="navbar-brand">ngoy - Docs</a>
			<button type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div id="navbarResponsive" class="collapse navbar-collapse">
				<ul class="navbar-nav ml-auto">

					<li class="nav-item"><a class="nav-link" href="index">Home </a></li><li class="nav-item"><a class="nav-link" href="get-started">Getting started </a></li><li class="nav-item active"><a class="nav-link" href="doc">Docs </a></li><li class="nav-item"><a class="nav-link" href="motivation">Motivation </a></li>

					<li class="nav-item"><a href="https://github.com/krizzdewizz/ngoy" target="_blank" class="nav-link">GitHub</a>
					</li>
				</ul>
			</div>
		</div>
	</nav>

	<!-- Page Content -->
	<div class="container app-container">
		<div class="row">
			<div class="col">
				<doc><ngoy-title><h1 class="mt-5 ngoy-title">Documentation</h1></ngoy-title>

<markdown url="doc/doc.md"><h2>Components and Templates</h2>
<p>A component is an ordinary Java class annotated with the <code>@Component</code> annotation:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, templateUrl = &quot;person.component.html&quot;)
public class PersonComponent {
}
</code></pre>
<p>Whenever ngoy encounters an element that matches the CSS selector <code>selector</code>, the component 'takes over' the element. The component then controls the element itself (aka host element) and it's content (including attributes).</p>
<p>The components template becomes the matching element's content.</p>
<p>Given this <code>person.component.html</code>:</p>
<pre><code class="language-html">&lt;h1&gt;Person details&lt;/h1&gt;
</code></pre>
<p>then this HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>will finally become:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;
		&lt;h1&gt;Person details&lt;/h1&gt;
	&lt;/person&gt;
&lt;/html&gt;
</code></pre>
<p>A component can specify it's template either by a <code>templateUrl</code> or an inline <code>template</code>. The <code>templateUrl</code> is loaded with a call to <code>Class#getResourceAsStream()</code>.</p>
<p>Inline template:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, template = &quot;&lt;h1&gt;Person details&lt;/h1&gt;&quot;)
public class PersonComponent {
}
</code></pre>
<h3>Template Syntax &amp; Data Binding</h3>
<p>A component has full control over the HTML by the use of data binding. There exists several possibilities:</p>
<h4>Interpolation</h4>
<p>The text inside double curly braces is interpreted as an expression:</p>
<pre><code class="language-html">&lt;h1&gt;Person details: {{ person.name }}&lt;/h1&gt;
</code></pre>
<p>At runtime, the expression is evaluated and it's return value is inserted instead.</p>
<p>Note: ngoy uses the <a href="https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html">Spring EL</a> library for expression/evaluation. Please consult their docs for what's possible. It's syntax is almost conform with Angular's. Notable differences to Angular see later in this document.</p>
<p>The component designates the 'context' (aka <code>this</code>) of the evaluation. So <code>person</code> in <code>{{ person.name }}</code> designates the <code>person</code> field of the <code>PersonComponent</code> instance:</p>
<pre><code class="language-java">public class Person {
	public String name;
	public int age;
}

@Component(selector = &quot;person&quot;, template = &quot;&lt;h1&gt;Person details: {{ person.name }}&lt;/h1&gt;&quot;)
public class PersonComponent {
	public Person person;
}
</code></pre>
<p>Interpolation can occur also inside of attribute values:</p>
<pre><code class="language-html">&lt;h1 title=&quot;hello {{person.name}}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h4>Attribute Binding</h4>
<p>Beside interpolation, an attribute's value can also be evaluated at runtime with the use of attribute bindings; the preferred way.</p>
<p>Regular (<code>String</code>) attribute:</p>
<pre><code class="language-html">&lt;h1 title=&quot;hello&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>The same with an attribute binding:</p>
<pre><code class="language-html">&lt;h1 [title]=&quot;person.name&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Just enclose the attribute's name with <code>[]</code> and it's value is interpreted as an expression.</p>
<p>Alternatively you can write also:</p>
<pre><code class="language-html">&lt;h1 [attr.title]=&quot;person.name&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>The <code>[attr.]</code> syntax is relevant when using the <code>@HostBinding</code> annotation, see later in this document.</p>
<h5><code>class</code> attribute</h5>
<p>The <code>class</code> attribute receives special treatment because it's value is effectively a class <em>list</em>.</p>
<p>A class can be added to the list by the use of the <code>[class.]</code> syntax:</p>
<pre><code class="language-html">&lt;h1 [class.vip]=&quot;isVip(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Which means: add <code>vip</code> to the class list if the result of the expression <code>isVip(person)</code> evaluates to <code>true</code>.</p>
<p>Several class bindings can occur:</p>
<pre><code class="language-html">&lt;h1 [class.vip]=&quot;isVip(person)&quot; [class.cool]=&quot;isCool(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If both evaluate to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 class=&quot;vip cool&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>An already existing class list will be merged into the final class list:</p>
<pre><code class="language-html">&lt;h1 class=&quot;person-title col-xs&quot; [class.vip]=&quot;isVip(person)&quot; [class.cool]=&quot;isCool(person)&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If both evaluate to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 class=&quot;person-title col-xs vip cool&quot;&gt;&lt;/h1&gt;
</code></pre>
<h5><code>ngClass</code> attribute</h5>
<p>If several classes must be computed at once, it can be tedious to write them all with <code>[class.]</code> bindings. With the help of the <code>ngClass</code> attribute, you can add them all at once.</p>
<p>It expects a <code>java.util.Map&lt;String, Boolean&gt;</code> as the expression result:</p>
<pre><code class="language-html">&lt;h1 [ngClass]=&quot;personClasses&quot;&gt;&lt;/h1&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	...
	public Map&lt;String, Boolean&gt; personClasses = new HashMap&lt;&gt;();
	
	public void ngOnInit() {
		personClasses.put(&quot;vip&quot;, isVip(person));
		personClasses.put(&quot;cool&quot;, isCool(person));
	}
}
</code></pre>
<p>Or as an expression using Spring EL map literals:</p>
<pre><code class="language-html">&lt;h1 [ngClass]=&quot;{vip: isVip(person), cool: isCool(person)}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h5><code>style</code> attribute</h5>
<p>The <code>style</code> attribute receives special treatment because it's value is effectively a <em>map</em> from the style's name to it's value.</p>
<p>A style entry can be added by the use of the <code>[style.]</code> syntax:</p>
<pre><code class="language-html">&lt;h1 [style.background-color]=&quot;isVip(person) ? 'red' : 'inherit'&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Which means: add <code>background-color</code> to the styles attribute with the value being the result of the expression.</p>
<p>If <code>isVip(person)</code> evaluates to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 style=&quot;background-color:red&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>You can append a unit to the style name, which is placed after the evaluated value:</p>
<pre><code class="language-html">&lt;h1 [style.width.px]=&quot;isVip(person) ? 240 : null&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>If <code>isVip(person)</code> evaluates to <code>true</code>:</p>
<pre><code class="language-html">&lt;h1 style=&quot;width:240px&quot;&gt;&lt;/h1&gt;
</code></pre>
<p>Already existing styles will be merged into the final map.</p>
<p>As opposed to Angular, styles must not be camelCased.</p>
<p>Angular:</p>
<pre><code>[style.backgroundColor]=&quot;'red'&quot;
</code></pre>
<p>ngoy:</p>
<pre><code>[style.background-color]=&quot;'red'&quot;
</code></pre>
<h5><code>ngStyle</code> attribute</h5>
<p>If several styles must be computed at once, it can be tedious to write them all with <code>[style.]</code> bindings. With the help of the <code>ngStyle</code> attribute, you can add them all at once.</p>
<p>It expects a <code>java.util.Map&lt;String, String&gt;</code> as the expression result:</p>
<pre><code class="language-html">&lt;h1 [ngStyle]=&quot;personStyles&quot;&gt;&lt;/h1&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	...
	public Map&lt;String, Boolean&gt; personStyles = new HashMap&lt;&gt;();
	
	public void ngOnInit() {
		personStyles.put(&quot;background-color&quot;, isVip(person) ? &quot;red&quot; : &quot;inherit&quot;);
		...
	}
}
</code></pre>
<p>Or as an expression using Spring EL map literals:</p>
<pre><code class="language-html">&lt;h1 [ngStyle]=&quot;{'background-color': isVip(person) ? 'red' : 'inherit'}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h4>@HostBinding</h4>
<p>The attributes of a component's host element can be dynamically set using the <code>@HostBinding</code> annotation. It is set on a component's field (or getter).</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;person&gt;&lt;/person&gt; &lt;!-- host element --&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">...
public class PersonComponent implements OnInit {
	@HostBinding(&quot;class.vip&quot;)
	public boolean isVip;
	
	public void ngOnInit() {
		isVip = isVip(person);
	}
}
</code></pre>
<p>The <code>@HostBinding</code>'s value is one of the bindings mentioned above (without the brackets): <code>attr.</code>, <code>class.</code>, <code>style.</code>. The type of the field  must correspond to the attribute kind:</p>
<ul>
<li><code>&quot;attr.title&quot;</code> -&gt; <code>String</code>. Value for the <code>title</code> attribute.</li>
<li><code>&quot;class.vip&quot;</code> -&gt; <code>boolean</code>. <code>true</code> if class <code>vip</code> should be added to the class list.</li>
<li><code>&quot;style.background-color&quot;</code> -&gt; <code>String</code>. Value for the style.</li>
<li><code>&quot;text&quot;</code> -&gt; <code>String</code>. Value for the element's text content. This is an extension to Angular.</li>
</ul>
<h3>Lifecycle hooks</h3>
<p>Ngoy supports two lifecycle hooks. <code>OnInit</code> and <code>OnDestroy</code>:</p>
<pre><code class="language-java">...
public class PersonComponent implements OnInit, OnDestroy {
	
	public void ngOnInit() {
	}

	public void ngOnDestroy() {
	}
}
</code></pre>
<p><code>ngOnInit()</code> is called in the rendering phase each time the component is entered (when it's host element starts).</p>
<p>Typically, a component computes 'expensive' field values in <code>ngOnInit()</code>, which are used several times in the template.</p>
<p>Note: A new component instance is created each time it is entered. Initialization can happen in the constructor, as long as no injected dependecies are used. At construction time, fields are not injected yet, but in <code>ngOnInit()</code>, they are.</p>
<p><code>ngOnDestroy()</code> is called in the rendering phase each time the component is leaved (when it's host element ends).</p>
<h3>Component interaction</h3>
<p>You can pass data from a parent component to a child component with an input binding:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	@Input
	public Person thePerson;
}

@Component(selector = &quot;&quot;, template = &quot;&lt;person [thePerson]=\&quot;peter\&quot;&gt;&lt;/person&gt;&quot;)
@NgModule(declarations = { PersonComponent.class })
public class AppComponent {
	public Person peter = new Person(&quot;Peter&quot;);
}
</code></pre>
<p><code>PersonComponent</code> declares <code>thePerson</code> field as an <code>@Input</code> binding.</p>
<p>The input parameter is passed to the <code>PersonComponent</code> instance with the use of an attribute binding <code>[thePerson]</code>:</p>
<pre><code class="language-html">&lt;person [thePerson]=&quot;peter&quot;&gt;&lt;/person&gt;
</code></pre>
<p><code>[]</code> designates an expression. its value, <code>peter</code>, is assigned to the component's input <code>thePerson</code>.</p>
<p>The <code>@Input</code> can optionally be renamed:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	@Input(&quot;personas&quot;)
	public Person thePerson;
}
</code></pre>
<pre><code class="language-html">&lt;person [personas]=&quot;peter&quot;&gt;&lt;/person&gt;
</code></pre>
<p>The <code>@Input</code> annotation can also be specified on a 'setter':</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
	private Person _person;
	
	@Input(&quot;personas&quot;)
	public void setThePerson(Person person) {
		_person = person;
	}
}
</code></pre>
<h3>Component styles</h3>
<p>A component can specify inline <code>style</code>s or resources identified by <code>styleUrls</code>:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, styles = { &quot;h1 { font-weight: normal; }&quot; }, styleUrls = {&quot;person.component.css&quot;} )
public class PersonComponent {
}
</code></pre>
<p>Upon compilation of the template, all styles from all declared components are copied into a single <code>&lt;style&gt;</code> element in the app's HTML.</p>
<h4>Auto Prefixer</h4>
<p>By default, styles are copied 'as-is'; they are global and not scoped to the component (no shadow DOM).</p>
<p>You can, however, opt-in to auto-prefixing:</p>
<pre><code class="language-java">Ngoy.app(AppComponent.class)
	.prefixCss(true) // enable auto-prefixer 
	.build();
</code></pre>
<p>All style rules are prefixed with the component's selector.</p>
<p>In the above example, with prefix enabled, the style</p>
<pre><code class="language-css">h1 { font-weight: normal; }
</code></pre>
<p>would be translated to:</p>
<pre><code class="language-css">person h1 { font-weight: normal; }
</code></pre>
<h3>Attribute directives</h3>
<p>Directives are annotated with the <code>@Directive</code> annotation:</p>
<pre><code class="language-java">@Directive(selector = &quot;[appHighlight]&quot;)
public class HighlightDirective {
	@HostBinding(&quot;style.background-color&quot;)
	public String getBgColor() {
	 	String color = ...;
		return color;
	}
}
</code></pre>
<p>A directive is aka a 'components without a template'. All rules of a component apply to a directive, except that the host element's content is not replaced by any template. So a directive serves merely to change the attributes of the host element with the use of <code>@HostBinding</code>s, or as a compile-time hook (see below).</p>
<h3>Components/directives compile-time hook</h3>
<p>When the template is compiled, a component/directive has the chance to alter the template's subtree before the compiler sees it. At this point, you can i.e. insert static content, re-write or expand a template based on some attributes etc.</p>
<p>A component/directive may implement the <code>OnCompile</code> interface:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent implements OnCompile {
	public void ngOnCompile(Jerry el, String componentClass) {
		// changes to the DOM element 'el', it's attributes and content will be picked up by the compiler
	}
}
</code></pre>
<p><code>ngOnCompile()</code> is called only <em>once</em> in the compile phase and not in the rendering phase.</p>
<p>See the <a href="https://github.com/krizzdewizz/ngoy-website/blob/master/src/main/java/ngoyweb/app/components/MarkdownComponent.java">MarkdownComponent</a> for an example. It appends the HTML converted from CommonMark. You can write markdown inside the component or reference a <code>.md</code> resource.</p>
<h3>Pipes</h3>
<p>A pipe takes in data as input and transforms it to a desired output. You can pipe the result of an expression to the desired pipe:</p>
<pre><code class="language-html">&lt;h1&gt;hello:  {{ person.name | uppercase }}&lt;/h1&gt;
</code></pre>
<p>These are the built-in pipes:</p>
<ul>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/UpperCasePipe.java">uppercase</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/LowerCasePipe.java">lowercase</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/CapitalizePipe.java">capitalize</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/DatePipe.java">date</a></li>
<li><a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/translate/TranslatePipe.java">translate</a> (see TranslateModule later in this document)</li>
</ul>
<p>You can of course write your own:</p>
<p>Annotate a Java class with <code>@Pipe</code> and implement the <code>PipeTransform</code> interface.</p>
<p>The original <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/common/UpperCasePipe.java">uppercase</a> source:</p>
<pre><code class="language-java">@Pipe(&quot;uppercase&quot;)
public class UpperCasePipe implements PipeTransform {

	@Inject
	public LocaleProvider localeProvider;

	@Override
	public Object transform(@Nullable Object obj, Object... params) {
		if (obj == null) {
			return null;
		}

		return obj.toString().toUpperCase(localeProvider.getLocale());
	}
}
</code></pre>
<p>Note: The pipe syntax <code>|</code> is not part of the Spring EL grammar. ngoy parses it manually with regex. It should be fine in most cases, but in complex expressions (which should be avoided anyway) it could lead to a parse error. In such a situation, you can always ressort to the function call syntax, prefixing the pipe with <code>$</code>:</p>
<pre><code class="language-java">'hello' | uppercase
</code></pre>
<p>is the same as:</p>
<pre><code class="language-java">$uppercase('hello')
</code></pre>
<h2>Modules</h2>
<p>All components, directives, pipes (declarations) and providers/services must be registered within ngoy.</p>
<p>Given the person example from above:</p>
<pre><code class="language-java">@Component(...)
public class PersonComponent {
}

@Component(selector = &quot;&quot;, template = &quot;&lt;person&gt;&lt;/person&gt;&quot;)
@NgModule(declarations = { PersonComponent.class }) // make PersonComponent known to ngoy
public class AppComponent {
	public Person peter = new Person(&quot;Peter&quot;);
}
</code></pre>
<p>Without the <code>NgModule</code> annotation, the <code>PersonComponent</code> would be unknown to ngoy and the <code>&lt;person&gt;</code> element would not match any selector and it would just stay there as it is.</p>
<p>A class annotated with <code>NgModule</code> serves as a container for declarations and providers. A logical unit to group a feature together. May a component needs a provider to work correctly. So you would group the two into a module, so that client of your component can import just the module instead of all parts separately. And you could add more stuff to the module afterwards without breaking the clients.</p>
<p>A <code>NgModule</code> has three attributes:</p>
<ul>
<li><code>declarations</code>: make components, directives and pipes known to ngoy</li>
<li><code>providers</code>: make providers/services known to ngoy</li>
<li><code>imports</code>: imports other <code>NgModule</code>s, making them known to ngoy recursively</li>
</ul>
<p>Note: Unlike other module systems, there exists no enforced boundaries between modules. At the end, everything is stuffed into a single map. Everything can be reached from anywhere.</p>
<p>A runtime exception is thrown whenever more than one component matches an element.</p>
<p>A provider can also be specified on a <code>@Component</code>:</p>
<pre><code class="language-java">@Component(selector = &quot;person&quot;, providers = { PersonService.class }) 
public class PersonComponent {
}
</code></pre>
<p>Component providers are <strong>never</strong> local to a component but <strong>always</strong> global.</p>
<h3>Dynamic Modules</h3>
<p>A dynamic module's declarations/providers are computed at runtime instead of 'declaration time' with annotations.</p>
<p>See <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/core/ModuleWithProviders.java">ModuleWithProviders.java</a> and
<a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/router/RouterModule.java">RouterModule.java</a> for an example usage.</p>
<h3>Package Modules</h3>
<p>It can be tedious to add every single thing to a module. And in an isolated app, there's no risk that there would be collisions.</p>
<p>In addition to organize declarations with modules, ngoy can scan the class path for them:</p>
<pre><code class="language-java">ngoy.app(AppComponent.class)
	.modules(&quot;org.myapp&quot;)                     // load all declarations/providers inside org.myapp package
	.modules(AppComponent.class.getPackage()) // load all declarations/providers inside the app's package
	.build();
</code></pre>
<h2>Dependency Injection</h2>
<p>Any class can be registered as a service/provider within ngoy and be injected into declarations and other services.</p>
<pre><code class="language-java">public class PersonService {
	public Person[] getPersons() {
		return ...;
	}
}

@Component(selector = &quot;person&quot;, providers = { PersonService.class }) 
public class PersonComponent implements OnInit {
	@Inject
	public PersonService personService;
	
	public void ngOnInit() {
		// do things with personService
	}
}
</code></pre>
<p>There are 3 kinds of providers:</p>
<ul>
<li><code>class A</code> -&gt; <code>class A</code>: Wherever <code>class A</code> is requested, inject an instance of <code>class A</code> (example above)</li>
<li><code>class A</code> -&gt; <code>useClass B</code>: Wherever <code>class A</code> is requested, inject an instance of <code>class B</code>. Used to override default behaviour, see below.</li>
<li><code>class A</code> -&gt; <code>useValue B</code>: Wherever <code>class A</code> is requested, inject the instance <code>B</code>. Only available at runtime, not with annotations.</li>
</ul>
<h3>Providers at runtime</h3>
<p>Providers can be specified at runtime, especially the <code>useValue</code> variant, which is used to inject external dependencies into ngoy.</p>
<pre><code class="language-java">ngoy.app(AppComponent.class)
	.providers(Provider.useValue(MyService.class, service)
	.build();
</code></pre>
<p>See also <a href="https://github.com/krizzdewizz/ngoy/blob/master/ngoy/src/main/java/ngoy/core/Provider.java">Provider.java</a></p>
<h3>External DI Systems</h3>
<p>By implementing the <code>Injector</code> interface, one can provide dependencies from other DI systems such as Spring Boot to ngoy.</p>
<p>See the <a href="https://github.com/krizzdewizz/ngoy-tour-of-heroes/blob/master/src/main/java/toh/app/BeanInjector.java">BeanInjector.java</a> for an example.</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/**&quot;)
public class Main implements InitializingBean {

	...

	@Autowired
	private BeanInjector beanInjector;

	private void createApp() {

		ngoy = Ngoy.app(AppComponent.class)
				...
				.injectors(beanInjector) // make Spring beans known to ngoy
				.build();
	}
}
</code></pre>
<h2>Routing</h2>
<p>Basic routing functionality can be found in the <code>RouterModule</code>. See the <a href="https://github.com/krizzdewizz/ngoy-examples/tree/master/src/main/java/ngoyexamples/routing">router</a> example in the <a href="https://github.com/krizzdewizz/ngoy-examples">ngoy-examples</a> collection.</p>
<h2>Forms</h2>
<p>to be done</p>
</markdown></doc>
			</div>
		</div>
	</div>

	<!-- Bootstrap core JavaScript -->
	<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<script>
	$(document).ready(function() {
	  $('pre code[class*=language]').each(function(i, block) {
	    hljs.highlightBlock(block);
	  });
	});
</script>
</body>

</html>
